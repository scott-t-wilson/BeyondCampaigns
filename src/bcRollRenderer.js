// import { RollBase, DiceExpressionRoll, GroupRoll, DiceRollResult, ExpressionRoll, DieRoll, FateDieRoll, MathFunctionRoll } from "dice-roller-parser";
import { gamelog, globals } from "./init.js";

// import { sources } from "webpack";
import { DiceRoller } from "dice-roller-parser";
var dice = new DiceRoller();

// console.log(dice.roll("2d20kh1+5"));
// console.log(dice.roll("2d20kl1+5"));
// console.log(dice.roll("1d20+5"));
// console.log(dice.roll("1d20"));

function uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
}

// var roll = {
//     "diceNotation": {
//         "set": [
//             {
//                 "dice": [
//                     // {
//                     //     "dieType": "d20",
//                     //     "dieValue": 14
//                     // }
//                 ],
//                 "count": 1,
//                 "dieType": "d20",
//                 "operation": 0
//             }
//         ],
//         "constant": 0
//     },
//     "diceNotationStr": "1d20",
//     "rollType": "roll",
//     "rollKind": "",
// }

/** An example renderer class that renders a roll to a string in a markdown format, compatible with Discord */
export class BCRollRenderer {
    /**
     * Renders a dice roll in a format compatible with BeyondCampaigns
     * @param roll a {@link RollBase} object that has been generated by the {@link DiceRoller}
     * @returns a string representing the roll that can be used on BeyondCampaigns
     */
    render(roll) {
        return this.doRender(roll, true);
    }

    doRender(roll, root = false) {
        let render = "";

        const type = roll.type;

        switch (type) {
            case "diceexpressionroll":
                render = this.renderGroupExpr(roll);
                break;
            case "grouproll":
                render = this.renderGroup(roll);
                break;
            case "die":
                render = this.renderDie(roll);
                break;
            case "expressionroll":
                render = this.renderExpression(roll);
                break;
            case "mathfunction":
                render = this.renderFunction(roll);
                break;
            case "roll":
                return this.renderRoll(roll);
            case "fateroll":
                return this.renderFateRoll(roll);
            case "number":
                const label = roll.label
                    ? ` (${roll.label})`
                    : "";
                return `${roll.value}${label}`;
            case "fate":
                return `F`;
            default:
                throw new Error("Unable to render");
        }

        if (!roll.valid) {
            render = "~~" + render.replace(/~~/g, "") + "~~";
        }

        if (root) {
            return this.stripBrackets(render);
        }

        return roll.label ? `(${roll.label}: ${render})` : render;
    }

    renderGroup(group) {
        const replies = [];

        for (const die of group.dice) {
            replies.push(this.doRender(die));
        }

        if (replies.length > 1) {
            return `{ ${replies.join("+")} } = ${group.value}`;
        }

        const reply = this.stripBrackets(replies[0]);
        return `{ ${reply} } = ${group.value}`;
    }

    renderGroupExpr(group) {
        const replies = [];

        for (const die of group.dice) {
            replies.push(this.doRender(die));
        }

        return replies.length > 1 ? `(${replies.join("+")} = ${group.value})` : replies[0];
    }

    renderDie(die) {
        const replies = [];

        for (const roll of die.rolls) {
            replies.push(this.doRender(roll));
        }

        let reply = `${replies.join(",")}`;

        if (!["number", "fate"].includes(die.die.type) || die.count.type !== "number") {
            reply += `[*Rolling: ${this.doRender(die.count)}d${this.doRender(die.die)}*]`;
        }

        const matches = die.matched
            ? ` Match${die.value === 1 ? "" : "es"}`
            : "";
        // reply += ` = ${die.value}${matches}`;
        return `(${reply})`;
    }

    renderExpression(expr) {
        if (expr.dice.length > 1) {
            const expressions = [];

            for (let i = 0; i < expr.dice.length - 1; i++) {
                expressions.push(this.doRender(expr.dice[i]));
                expressions.push(expr.ops[i]);
            }

            expressions.push(this.doRender(expr.dice.slice(-1)[0]));
            // expressions.push("=");
            // expressions.push(expr.value + "");

            return `(${expressions.join("")})`;
        } else if (expr.dice[0].type === "number") {
            return expr.value + "";
        } else {
            return this.doRender(expr.dice[0]);
        }
    }

    renderFunction(roll) {
        const render = this.doRender(roll.expr);
        return roll.value;
        return `(${roll.op}${this.addBrackets(render)} = ${roll.value})`;
    }

    addBrackets(render) {
        if (!render.startsWith("(")) {
            render = `(${render}`;
        }
        if (!render.endsWith(")")) {
            render = `${render})`;
        }
        return render;
    }

    stripBrackets(render) {
        if (render.startsWith("(")) {
            render = render.substring(1);
        }
        if (render.endsWith(")")) {
            render = render.substring(0, render.length - 1);
        }
        return render;
    }

    renderRoll(roll) {
        return roll.roll;
        let rollDisplay = `${roll.roll}`;
        if (!roll.valid) {
            rollDisplay = `~~${roll.roll}~~`;
        } else if (roll.success && roll.value === 1) {
            rollDisplay = `**${roll.roll}**`;
        } else if (roll.success && roll.value === -1) {
            rollDisplay = `*${roll.roll}*`;
        } else if (!roll.success && roll.critical === "success") {
            rollDisplay = `**${roll.roll}**`;
        } else if (!roll.success && roll.critical === "failure") {
            rollDisplay = `*${roll.roll}*`;
        }

        if (roll.matched) {
            rollDisplay = `__${rollDisplay}__`;
        }

        return rollDisplay;
    }

    renderFateRoll(roll) {
        const rollValue = roll.roll === 0
            ? "0"
            : roll.roll > 0
                ? "+"
                : "-";

        let rollDisplay = `${roll.roll}`;
        if (!roll.valid) {
            rollDisplay = `~~${rollValue}~~`;
        } else if (roll.success && roll.value === 1) {
            rollDisplay = `**${rollValue}**`;
        } else if (roll.success && roll.value === -1) {
            rollDisplay = `*${rollValue}*`;
        }

        if (roll.matched) {
            rollDisplay = `__${rollDisplay}__`;
        }

        return rollDisplay;
    }
}

var rollRender = new BCRollRenderer()


export class BCRollLogger {

    constructor(character, gameId) {
        this.id = null; // set to fresh uuid when logged
        this.dateTime = null; // set when logged
        this.gameId = globals.gameId;
        this.userId = globals.userId;
        this.source = "web";
        this.entityId = character.id.toString();
        this.entityType = "character";
        this.eventType = "dice/roll/fulfilled"; //dice/roll/pending
        this.persist = true;
        this.messageScope = "gameId";
        this.messageTarget = globals.gameId;
        this.gamelogReceive = true;
        this.data = {
            rolls: [],
            action: "",
            context: {
                entityId: character.id.toString(),
                entityType: "character",
                name: character.name,
                avatarUrl: character.avatarUrl,
                messageScope: "gameId",
                messageTarget: globals.gameId,
            },
            rollId: null,
            setId: "00101", //standard black/red dice
        };
    }

    set_user_game(userId, gameId){
        this.userId = userId.toString();
        this.gameId = gameId.toString();
        if(this.messageScope == "gameId"){
            this.messageTarget = gameId.toString();
        }
        if(this.messageScope == "gameId"){
            this.messageTarget = gameId.toString();
        }
        if(this.data.context.messageScope == "gameId"){
            this.data.context.messageTarget = gameId.toString();
        }
   }

    d20(options){
        // options = {
        //     action: "",  // Mace | con | Stealth
        //     rollType: "",  // damage | to hit | save | check
        //     rollKind: "",  // disadvantage | advantage
        //     modifer: "",  // +X | -Y
        //     log: true|false  send to gameLog
        // }
    
        let api_roll = {
            diceNotation: {
                set: [{
                    dice: [],
                    count: 1,
                    dieType: "d20",
                    operation: 0, // Seems to be +1 per roll, and sometimes +1 for bonus
                    // operand: 0  // 1 on dis/adv rolls, 0 on flat?
                }],
                constant: 0
            },
            diceNotationStr: "",
            rollType: "",
            rollKind: "",
        }
    
        this.data.action = options.action;
        this.data.rollId = uuidv4();

        // Build the roll string for a d20
        let rollString = "1d20";
        if(options.rollKind == "advantage"){
            rollString = "2d20kh1";
            // still have no idea what these mean
            api_roll.diceNotation.set[0].operation = 2;
            api_roll.diceNotation.set[0].operand = 1;
        }
        if(options.rollKind == "disadvantage"){
            rollString = "2d20kl1";
            // still have no idea what these mean
            api_roll.diceNotation.set[0].operation = 2;
            api_roll.diceNotation.set[0].operand = 1;
        }
        // Format the bonus so we don't have a '+-1'
        let bonus = parseInt(options.modifer);
        if (bonus > 0) {
            rollString += "+" + bonus;
        }
        if (bonus < 0) {
            rollString += bonus;
        }
        api_roll.diceNotation.constant = bonus;
        
        // Roll it!
        let roll = dice.roll(rollString);

        // Put together the result
        let result = {
            constant: bonus,
            values: [],
            total: roll.value,
            text: rollRender.render(roll)
        }        
        // NOTE: if we decide to do a pre-roll message, don't assign this yet
        api_roll.result = result;
        
        // Assemble the die notation
        let inner_rolls = roll.rolls;
        if(roll.dice){
            inner_rolls = roll.dice[0].rolls;
        }
        inner_rolls.forEach(die => { 
            api_roll.diceNotation.set[0].dice.push({
                dieType: "d20",
                dieValue: die.value
            });
            result.values.push(die.value.toString())
        })
        api_roll.diceNotation.set[0].count = inner_rolls.length;
        api_roll.diceNotationStr = rollString;
        api_roll.rollType = options.rollType;
        api_roll.rollKind = options.rollKind;
        this.data.rolls = [api_roll];


        if(options.log){
            this.log(); 
        }
        return result.total;
    }

    log(){
        this.id = uuidv4();
        this.dateTime = Date.now().toString();
        console.dir(this);
        gamelog.send(this);     
    }

    render(roll) {
        return this.doRender(roll, true);
    }

}

// var roll_logger = new BCRollLogger({
//     name: "Testy McTest",
//     avatarUrl: "example.com",
//     userId: 110560288,
//     id: 110560288,
// }, 2156849);
 
// roll_logger.d20({
//     action: "con",  // Mace | con | Stealth
//     rollType: "check",  // damage | to hit | save | check
//     rollKind: "disadvantage",  // disadvantage | advantage
//     modifer: "-1",  // +X | -Y
//     log: true,
// })


