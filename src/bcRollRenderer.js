// import { RollBase, DiceExpressionRoll, GroupRoll, DiceRollResult, ExpressionRoll, DieRoll, FateDieRoll, MathFunctionRoll } from "dice-roller-parser";
import { gamelog, globals } from "./init.js";

// import { sources } from "webpack";
import { DiceRoller } from "dice-roller-parser";
var dice = new DiceRoller();

// console.log(dice.roll("2d20kh1+5"));
// console.log(dice.roll("2d20kl1+5"));
// console.log(dice.roll("1d20+5"));
// console.log(dice.roll("1d20"));

function uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
}

// var roll = {
//     "diceNotation": {
//         "set": [
//             {
//                 "dice": [
//                     // {
//                     //     "dieType": "d20",
//                     //     "dieValue": 14
//                     // }
//                 ],
//                 "count": 1,
//                 "dieType": "d20",
//                 "operation": 0
//             }
//         ],
//         "constant": 0
//     },
//     "diceNotationStr": "1d20",
//     "rollType": "roll",
//     "rollKind": "",
// }

/** An example renderer class that renders a roll to a string in a markdown format, compatible with Discord */
export class BCRollRenderer {
    /**
     * Renders a dice roll in a format compatible with BeyondCampaigns
     * @param roll a {@link RollBase} object that has been generated by the {@link DiceRoller}
     * @returns a string representing the roll that can be used on BeyondCampaigns
     */
    render(roll) {
        return this.doRender(roll, true);
    }

    doRender(roll, root = false) {
        let render = "";

        const type = roll.type;

        switch (type) {
            case "diceexpressionroll":
                render = this.renderGroupExpr(roll);
                break;
            case "grouproll":
                render = this.renderGroup(roll);
                break;
            case "die":
                render = this.renderDie(roll);
                break;
            case "expressionroll":
                render = this.renderExpression(roll);
                break;
            case "mathfunction":
                render = this.renderFunction(roll);
                break;
            case "roll":
                return this.renderRoll(roll);
            case "fateroll":
                return this.renderFateRoll(roll);
            case "number":
                const label = roll.label
                    ? ` (${roll.label})`
                    : "";
                return `${roll.value}${label}`;
            case "fate":
                return `F`;
            default:
                throw new Error("Unable to render");
        }

        if (!roll.valid) {
            render = "~~" + render.replace(/~~/g, "") + "~~";
        }

        if (root) {
            return this.stripBrackets(render);
        }

        return roll.label ? `(${roll.label}: ${render})` : render;
    }

    renderGroup(group) {
        const replies = [];

        for (const die of group.dice) {
            replies.push(this.doRender(die));
        }

        if (replies.length > 1) {
            return `{ ${replies.join("+")} } = ${group.value}`;
        }

        const reply = this.stripBrackets(replies[0]);
        return `{ ${reply} } = ${group.value}`;
    }

    renderGroupExpr(group) {
        const replies = [];

        for (const die of group.dice) {
            replies.push(this.doRender(die));
        }

        return replies.length > 1 ? `(${replies.join("+")} = ${group.value})` : replies[0];
    }

    renderDie(die) {
        const replies = [];

        for (const roll of die.rolls) {
            replies.push(this.doRender(roll));
        }

        let reply = `${replies.join(",")}`;

        if (!["number", "fate"].includes(die.die.type) || die.count.type !== "number") {
            reply += `[*Rolling: ${this.doRender(die.count)}d${this.doRender(die.die)}*]`;
        }

        const matches = die.matched
            ? ` Match${die.value === 1 ? "" : "es"}`
            : "";
        // reply += ` = ${die.value}${matches}`;
        return `(${reply})`;
    }

    renderExpression(expr) {
        if (expr.dice.length > 1) {
            const expressions = [];

            for (let i = 0; i < expr.dice.length - 1; i++) {
                expressions.push(this.doRender(expr.dice[i]));
                expressions.push(expr.ops[i]);
            }

            expressions.push(this.doRender(expr.dice.slice(-1)[0]));
            // expressions.push("=");
            // expressions.push(expr.value + "");

            return `(${expressions.join("")})`;
        } else if (expr.dice[0].type === "number") {
            return expr.value + "";
        } else {
            return this.doRender(expr.dice[0]);
        }
    }

    renderFunction(roll) {
        const render = this.doRender(roll.expr);
        return roll.value;
        return `(${roll.op}${this.addBrackets(render)} = ${roll.value})`;
    }

    addBrackets(render) {
        if (!render.startsWith("(")) {
            render = `(${render}`;
        }
        if (!render.endsWith(")")) {
            render = `${render})`;
        }
        return render;
    }

    stripBrackets(render) {
        if (render.startsWith("(")) {
            render = render.substring(1);
        }
        if (render.endsWith(")")) {
            render = render.substring(0, render.length - 1);
        }
        return render;
    }

    renderRoll(roll) {
        return roll.roll;
        let rollDisplay = `${roll.roll}`;
        if (!roll.valid) {
            rollDisplay = `~~${roll.roll}~~`;
        } else if (roll.success && roll.value === 1) {
            rollDisplay = `**${roll.roll}**`;
        } else if (roll.success && roll.value === -1) {
            rollDisplay = `*${roll.roll}*`;
        } else if (!roll.success && roll.critical === "success") {
            rollDisplay = `**${roll.roll}**`;
        } else if (!roll.success && roll.critical === "failure") {
            rollDisplay = `*${roll.roll}*`;
        }

        if (roll.matched) {
            rollDisplay = `__${rollDisplay}__`;
        }

        return rollDisplay;
    }

    renderFateRoll(roll) {
        const rollValue = roll.roll === 0
            ? "0"
            : roll.roll > 0
                ? "+"
                : "-";

        let rollDisplay = `${roll.roll}`;
        if (!roll.valid) {
            rollDisplay = `~~${rollValue}~~`;
        } else if (roll.success && roll.value === 1) {
            rollDisplay = `**${rollValue}**`;
        } else if (roll.success && roll.value === -1) {
            rollDisplay = `*${rollValue}*`;
        }

        if (roll.matched) {
            rollDisplay = `__${rollDisplay}__`;
        }

        return rollDisplay;
    }
}

var rollRender = new BCRollRenderer()


//
// new BCRollLogger({
//     entityId: character.id.toString(),
//     entityType: "character",
//     contextName: character.name,
//     contextAvatarUrl: character.avatarUrl,
// })
//
export class BCRollLogger {

    constructor(options) {
        this.id = null; // set to fresh uuid when logged
        this.dateTime = null; // set when logged
        this.gameId = globals.gameId;
        this.userId = globals.userId;
        this.source = "web";
        this.entityId = options.entityId;
        this.entityType = options.entityType;
        this.eventType = "dice/roll/fulfilled"; //dice/roll/pending
        this.persist = true;
        this.messageScope = "gameId";
        this.messageTarget = globals.gameId;
        this.gamelogReceive = true;
        this.data = {
            rolls: [],
            action: "",
            context: {
                entityId: options.entityId,
                entityType: options.entityType,
                name: options.contextName,
                avatarUrl: options.contextAvatarUrl,
                messageScope: "gameId",
                messageTarget: globals.gameId,
            },
            rollId: null,
            setId: "00101", //standard black/red dice
        };
    }

    // set_user_game(userId, gameId) {
    //     this.userId = userId.toString();
    //     this.gameId = gameId.toString();
    //     if (this.messageScope == "gameId") {
    //         this.messageTarget = gameId.toString();
    //     }
    //     if (this.messageScope == "gameId") {
    //         this.messageTarget = gameId.toString();
    //     }
    //     if (this.data.context.messageScope == "gameId") {
    //         this.data.context.messageTarget = gameId.toString();
    //     }
    // }

    roll(options) {
        // options = {
        //     action: "",  // Mace | con | Stealth | Initiative
        //     rollType: "",  // damage | to hit | save | check | roll
        //     rollKind: "",  // disadvantage | advantage | critical hit
        //     modifier: "",  // +X | -Y
        //     log: true|false  send to gameLog
        // }
        if (options.d20 == undefined) {
            options.d20 = true;
        }
        if(options.notation == undefined){
            options.notation = "1d20";
        }
        if(options.publicRoll === false){
            this.messageScope = "userId";
            this.messageTarget = this.userId;
            this.data.context.messageScope = "userId";
            this.data.context.messageTarget = this.userId;
        }else{
            this.messageScope = "gameId";
            this.messageTarget = this.gameId;
            this.data.context.messageScope = "gameId";
            this.data.context.messageTarget = this.gameId;
        }

        let api_roll = {
            diceNotation: {
                set: [{
                    dice: [],
                    count: 1,
                    dieType: "d20",
                    operation: 0, // Seems to be +1 per roll, and sometimes +1 for bonus
                    // operand: 0  // 1 on dis/adv rolls, 0 on flat?
                }],
                constant: 0
            },
            diceNotationStr: options.notation,
            rollType: options.rollType,
            rollKind: options.rollKind,
        }
        this.data.action = options.action;
        this.data.rollId = uuidv4();

        if (options.d20) {
            // Build the roll string for a d20
            if (options.rollKind == "advantage") {
                api_roll.diceNotationStr = "2d20kh1";
                // still have no idea what these mean
                api_roll.diceNotation.set[0].operation = 2;
                api_roll.diceNotation.set[0].operand = 1;
            }
            if (options.rollKind == "disadvantage") {
                api_roll.diceNotationStr = "2d20kl1";
                // still have no idea what these mean
                api_roll.diceNotation.set[0].operation = 2;
                api_roll.diceNotation.set[0].operand = 1;
            }
            // Format the bonus so we don't have a '+-1'
            let bonus = parseInt(options.modifier);
            if (bonus > 0) {
                api_roll.diceNotationStr += "+" + bonus;
            }
            if (bonus < 0) {
                api_roll.diceNotationStr += bonus;
            }
            api_roll.diceNotation.constant = bonus;
        } else {
            let arr = api_roll.diceNotationStr.match(/([\\+-]\d*)/);
            console.log("api_roll.diceNotationStr.match:", arr);
            if (arr && arr.length == 2) {
                api_roll.diceNotation.constant = parseInt(arr[1]);
            }
            if(options.rollKind == "critical"){
                let re = /(\d+)d/g;
                api_roll.diceNotationStr = re[Symbol.replace](api_roll.diceNotationStr, m =>{
                    return parseInt(m)*2 + "d"
                });
            }
        }
        // Roll it!
        console.log("api_roll:", api_roll);
        let roll = dice.roll(api_roll.diceNotationStr);
        console.log("roll:", roll);

        // Put together the result
        let result = {
            constant: api_roll.diceNotation.constant,
            values: [],
            total: roll.value,
            text: rollRender.render(roll)
        }
        // NOTE: if we decide to do a pre-roll message, don't assign this yet
        api_roll.result = result;

        // Assemble the die notation
        let inner_rolls = roll.rolls;
        if (roll.dice) {
            inner_rolls = roll.dice[0].rolls;
        }
        // TODO: This breaks if there is more than one kind of die
        inner_rolls.forEach(die => {
            api_roll.diceNotation.set[0].dice.push({
                dieType: "d" + die.die,
                dieValue: die.value
            });
            api_roll.diceNotation.set[0].dieType = "d" + die.die;
            result.values.push(die.value.toString())
        })
        api_roll.diceNotation.set[0].count = inner_rolls.length;
        this.data.rolls = [api_roll];


        if (options.log) {
            this.log();
        }
        return result.total;
    }

    log() {
        this.id = uuidv4();
        this.dateTime = Date.now().toString();
        // console.dir(this);
        gamelog.send(this);
    }

    render(roll) {
        return this.doRender(roll, true);
    }

}

// var roll_logger = new BCRollLogger({
//     name: "Testy McTest",
//     avatarUrl: "example.com",
//     userId: 110560288,
//     id: 110560288,
// }, 2156849);

// roll_logger.d20({
//     action: "con",  // Mace | con | Stealth
//     rollType: "check",  // damage | to hit | save | check
//     rollKind: "disadvantage",  // disadvantage | advantage
//     modifier: "-1",  // +X | -Y
//     log: true,
// })


